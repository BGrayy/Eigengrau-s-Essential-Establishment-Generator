// operations, by chapel; for sugarcube 2.x
// v1.0.0
// adds a dice roller and 'fairmath'

// options object
setup.operations = {
  fmRange: [0, 100]
}

/*
	I couldn't decide on which syntax mode was best, especially for dice.
	So I wound up including a bunch of options, and they all work essentially the same way.
	Though the dice 'parser' [e.g. dice('string')] syntax and the shortcuts [e.g. x.fm(), x.d()]
	perform slightly worse / are slightly slower than the other potential syntax modes.
	Supported syntax:
		1. the dice roller: (all the following work and are all equivalent to '3d6+10')
			a. dice(3, 6) + 10
			b. dice('3d6 + 10')
			c. dice('3d6+10')
			d. dice('3d6') + 10
			e. !!! dice('3d6' + 10) -- Will roll 3 610-sided dice; the parser can't accept mixed arguments
		2. the fairmath system (based on the ChoiceScript stats system)
			c. Math.fm(50, 40)      [=70]
		3. Notes.
			a. be careful! rolling dice with floating point numbers or negatives will cause errors
			b. likewise, fairmath will spit out errors if it's given bizarre numbers

	Options:
		tryGlobal : sends diceHelpers.roll() to the global scope as dice() if true
		nicknames : include the shorter method calls [Math.fm(), <number>.fm(), and <number>.d()]
		fmRange   : move the minimum and maximum range for the fairmath system, if you need to
					note that the results are constrained by this range, but can never actually hit it
					that is, [0, 100] will limit the actual numbers to 1-99,
					[10, 45] would limit the results to 11-44, etc.
*/

/*					DICE					*/

const diceHelpers = {
  processDice: (a, b) => {
		// find the number of dice and the type of die
    let roll = [], result = 0
    if (typeof a === 'string') {
      roll = a.split('d')
    } else if (typeof a === 'number' && b) {
      roll = [a, b]
    } else if (Array.isArray(a) && a.length >= 2) {
      a.length = 2
      roll = a
    } else {
      throw new TypeError('diceHelpers.processDice(): could not process arguments...')
    }
    for (let i = 0; i < roll[0]; i++) {
			/*
				we're going to roll each die.  we could generate a number
				between the max and min possible simply enough,
				but real dice have weights -- rolling 3d6 is far more likely to result
				in 10 or 11 than in 3 or 18, and pure randomization will not emulate this
			*/
      const die = Math.floor(randomFloat(1) * roll[1]) + 1
      result += die // update result
    }
    return result // this preliminary result ignores modifiers; it only rolls the dice
  },
  processString: (string) => {
		// receives strings like '1d6 + 6' or 1d20+3'
    let parsed = []
		// remove all whitespace and trim
    string = string.trim().replace(/\s/g, '')
		// check for and return the parts of the roll (2 chunks: '1d6' and '+6')
    parsed = string.match(/(\d*d\d*)(.*)/)
    return [parsed[1], Number(parsed[2])] // send the data off as an array
  },
  roll: (a, b) => {
    if (typeof a === 'string') {
      const result = diceHelpers.processString(a)
			/*
				the expression below rolls the dice and adds the modifier,
				which must be additive (i.e. +5 or -5, but never *5)
			*/
      return diceHelpers.processDice(result[0]) + result[1]
    } else {
			// just run it, it'll toss out its own errors
      return diceHelpers.processDice(a, b)
    }
  }
}

// global dice() function; dice('[x]d[y] +/- [z]') -or- dice(2, 10) [2d10]
// ex. $var = dice('2d10+5'); _var = dice('3d6 - 1'); _var = dice(3, 6) + 10; etc
window.dice = window.dice || diceHelpers.roll

// send to global scope without breaking anything

/* FAIRMATH */

// fairmath method; fairmath(base, value)
const fairmath = (base, val) => {
  // errors
  const op = setup.operations.fmRange

  if (val == null || typeof val !== 'number' || val > 100 || val < -100) {
    throw new TypeError('fairmath given incorrect argument or an argument that is out of the valid 0-100 range.')
  }

  // do the 'fair' math!
  if (val === 0) { // a 0 increase or decrease; just trunc and clamp
    return Math.clamp(Math.trunc(base), op[0], op[1])
  }
  if (val < 0) { // number is negative, representing a decrease
    val = val * -1 // make positive for the math below
    return Math.clamp(Math.trunc(
      base - ((base - op[0]) * (val / op[1]))
    ), op[0], op[1])
  }
  if (val > 0) { // number is positive, representing an increase
    return Math.clamp(Math.trunc(
      base + ((op[1] - base) * (val / op[1]))
    ), op[0], op[1])
  }
  // something inexplicable happened
  throw new Error('fairmath encountered an unspecified error.')
}

/* EXTRAS */

if (!Math.fm) {
  // Math.fm()
  Object.defineProperty(Math, 'fm', {
    configurable: true,
    writable: true,

    value (base, val) {
      return fairmath(base, val)
    }
  })
}
